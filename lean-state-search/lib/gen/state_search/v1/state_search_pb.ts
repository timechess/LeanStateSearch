// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file state_search/v1/state_search.proto (package state_search.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * A theorem from Mathlib
 *
 * @generated from message state_search.v1.Theorem
 */
export class Theorem extends Message<Theorem> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string code = 3;
   */
  code = "";

  /**
   * @generated from field: string rev = 4;
   */
  rev = "";

  /**
   * @generated from field: string module = 5;
   */
  module = "";

  /**
   * @generated from field: string formal_type = 6;
   */
  formalType = "";

  constructor(data?: PartialMessage<Theorem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.Theorem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "rev", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "module", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 6,
      name: "formal_type",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Theorem {
    return new Theorem().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Theorem {
    return new Theorem().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Theorem {
    return new Theorem().fromJsonString(jsonString, options);
  }

  static equals(
    a: Theorem | PlainMessage<Theorem> | undefined,
    b: Theorem | PlainMessage<Theorem> | undefined,
  ): boolean {
    return proto3.util.equals(Theorem, a, b);
  }
}

/**
 * @generated from message state_search.v1.GetAllRevRequest
 */
export class GetAllRevRequest extends Message<GetAllRevRequest> {
  constructor(data?: PartialMessage<GetAllRevRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.GetAllRevRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetAllRevRequest {
    return new GetAllRevRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetAllRevRequest {
    return new GetAllRevRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetAllRevRequest {
    return new GetAllRevRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetAllRevRequest | PlainMessage<GetAllRevRequest> | undefined,
    b: GetAllRevRequest | PlainMessage<GetAllRevRequest> | undefined,
  ): boolean {
    return proto3.util.equals(GetAllRevRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.GetAllRevResponse
 */
export class GetAllRevResponse extends Message<GetAllRevResponse> {
  /**
   * @generated from field: repeated string revs = 1;
   */
  revs: string[] = [];

  constructor(data?: PartialMessage<GetAllRevResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.GetAllRevResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: "revs",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetAllRevResponse {
    return new GetAllRevResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetAllRevResponse {
    return new GetAllRevResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetAllRevResponse {
    return new GetAllRevResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: GetAllRevResponse | PlainMessage<GetAllRevResponse> | undefined,
    b: GetAllRevResponse | PlainMessage<GetAllRevResponse> | undefined,
  ): boolean {
    return proto3.util.equals(GetAllRevResponse, a, b);
  }
}

/**
 * @generated from message state_search.v1.SearchTheoremRequest
 */
export class SearchTheoremRequest extends Message<SearchTheoremRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: int32 nresult = 2;
   */
  nresult = 0;

  /**
   * @generated from field: string rev = 3;
   */
  rev = "";

  constructor(data?: PartialMessage<SearchTheoremRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.SearchTheoremRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nresult", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "rev", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): SearchTheoremRequest {
    return new SearchTheoremRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): SearchTheoremRequest {
    return new SearchTheoremRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): SearchTheoremRequest {
    return new SearchTheoremRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: SearchTheoremRequest | PlainMessage<SearchTheoremRequest> | undefined,
    b: SearchTheoremRequest | PlainMessage<SearchTheoremRequest> | undefined,
  ): boolean {
    return proto3.util.equals(SearchTheoremRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.SearchTheoremResponse
 */
export class SearchTheoremResponse extends Message<SearchTheoremResponse> {
  /**
   * @generated from field: repeated state_search.v1.Theorem results = 1;
   */
  results: Theorem[] = [];

  constructor(data?: PartialMessage<SearchTheoremResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.SearchTheoremResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: Theorem, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): SearchTheoremResponse {
    return new SearchTheoremResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): SearchTheoremResponse {
    return new SearchTheoremResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): SearchTheoremResponse {
    return new SearchTheoremResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: SearchTheoremResponse | PlainMessage<SearchTheoremResponse> | undefined,
    b: SearchTheoremResponse | PlainMessage<SearchTheoremResponse> | undefined,
  ): boolean {
    return proto3.util.equals(SearchTheoremResponse, a, b);
  }
}

/**
 * @generated from message state_search.v1.FeedbackRequest
 */
export class FeedbackRequest extends Message<FeedbackRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: string theorem_id = 2;
   */
  theoremId = "";

  /**
   * @generated from field: bool relevant = 3;
   */
  relevant = false;

  /**
   * @generated from field: bool update = 4;
   */
  update = false;

  /**
   * @generated from field: int32 rank = 5;
   */
  rank = 0;

  constructor(data?: PartialMessage<FeedbackRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.FeedbackRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "theorem_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relevant", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 5, name: "rank", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): FeedbackRequest {
    return new FeedbackRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): FeedbackRequest {
    return new FeedbackRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FeedbackRequest {
    return new FeedbackRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: FeedbackRequest | PlainMessage<FeedbackRequest> | undefined,
    b: FeedbackRequest | PlainMessage<FeedbackRequest> | undefined,
  ): boolean {
    return proto3.util.equals(FeedbackRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.FeedbackResponse
 */
export class FeedbackResponse extends Message<FeedbackResponse> {
  constructor(data?: PartialMessage<FeedbackResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.FeedbackResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): FeedbackResponse {
    return new FeedbackResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): FeedbackResponse {
    return new FeedbackResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): FeedbackResponse {
    return new FeedbackResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: FeedbackResponse | PlainMessage<FeedbackResponse> | undefined,
    b: FeedbackResponse | PlainMessage<FeedbackResponse> | undefined,
  ): boolean {
    return proto3.util.equals(FeedbackResponse, a, b);
  }
}

/**
 * @generated from message state_search.v1.ClickRequest
 */
export class ClickRequest extends Message<ClickRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: string theorem_id = 2;
   */
  theoremId = "";

  /**
   * @generated from field: int32 rank = 3;
   */
  rank = 0;

  constructor(data?: PartialMessage<ClickRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.ClickRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "theorem_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "rank", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ClickRequest {
    return new ClickRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ClickRequest {
    return new ClickRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ClickRequest {
    return new ClickRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClickRequest | PlainMessage<ClickRequest> | undefined,
    b: ClickRequest | PlainMessage<ClickRequest> | undefined,
  ): boolean {
    return proto3.util.equals(ClickRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.ClickResponse
 */
export class ClickResponse extends Message<ClickResponse> {
  constructor(data?: PartialMessage<ClickResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.ClickResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ClickResponse {
    return new ClickResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ClickResponse {
    return new ClickResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ClickResponse {
    return new ClickResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClickResponse | PlainMessage<ClickResponse> | undefined,
    b: ClickResponse | PlainMessage<ClickResponse> | undefined,
  ): boolean {
    return proto3.util.equals(ClickResponse, a, b);
  }
}

/**
 * @generated from message state_search.v1.CallRequest
 */
export class CallRequest extends Message<CallRequest> {
  /**
   * @generated from field: int32 call_type = 1;
   */
  callType = 0;

  constructor(data?: PartialMessage<CallRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.CallRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "call_type", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CallRequest {
    return new CallRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CallRequest {
    return new CallRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CallRequest {
    return new CallRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a: CallRequest | PlainMessage<CallRequest> | undefined,
    b: CallRequest | PlainMessage<CallRequest> | undefined,
  ): boolean {
    return proto3.util.equals(CallRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.CallResponse
 */
export class CallResponse extends Message<CallResponse> {
  constructor(data?: PartialMessage<CallResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.CallResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => []);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): CallResponse {
    return new CallResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): CallResponse {
    return new CallResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): CallResponse {
    return new CallResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a: CallResponse | PlainMessage<CallResponse> | undefined,
    b: CallResponse | PlainMessage<CallResponse> | undefined,
  ): boolean {
    return proto3.util.equals(CallResponse, a, b);
  }
}

/**
 * @generated from message state_search.v1.LeanNode
 */
export class LeanNode extends Message<LeanNode> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: string const_category = 2;
   */
  constCategory = "";

  /**
   * @generated from field: string const_type = 3;
   */
  constType = "";

  /**
   * @generated from field: string module = 4;
   */
  module = "";

  /**
   * @generated from field: string doc_string = 5;
   */
  docString = "";

  /**
   * @generated from field: string informal_name = 6;
   */
  informalName = "";

  /**
   * @generated from field: string informal_statement = 7;
   */
  informalStatement = "";

  constructor(data?: PartialMessage<LeanNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.LeanNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 2,
      name: "const_category",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    { no: 3, name: "const_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "module", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "doc_string", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    {
      no: 6,
      name: "informal_name",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 7,
      name: "informal_statement",
      kind: "scalar",
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): LeanNode {
    return new LeanNode().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): LeanNode {
    return new LeanNode().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): LeanNode {
    return new LeanNode().fromJsonString(jsonString, options);
  }

  static equals(
    a: LeanNode | PlainMessage<LeanNode> | undefined,
    b: LeanNode | PlainMessage<LeanNode> | undefined,
  ): boolean {
    return proto3.util.equals(LeanNode, a, b);
  }
}

/**
 * @generated from message state_search.v1.LeanEdge
 */
export class LeanEdge extends Message<LeanEdge> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string source = 2;
   */
  source = "";

  /**
   * @generated from field: string target = 3;
   */
  target = "";

  /**
   * @generated from field: int32 weight = 4;
   */
  weight = 0;

  constructor(data?: PartialMessage<LeanEdge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.LeanEdge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "weight", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): LeanEdge {
    return new LeanEdge().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): LeanEdge {
    return new LeanEdge().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): LeanEdge {
    return new LeanEdge().fromJsonString(jsonString, options);
  }

  static equals(
    a: LeanEdge | PlainMessage<LeanEdge> | undefined,
    b: LeanEdge | PlainMessage<LeanEdge> | undefined,
  ): boolean {
    return proto3.util.equals(LeanEdge, a, b);
  }
}

/**
 * @generated from message state_search.v1.GetNodesAndEdgesRequest
 */
export class GetNodesAndEdgesRequest extends Message<GetNodesAndEdgesRequest> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<GetNodesAndEdgesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.GetNodesAndEdgesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetNodesAndEdgesRequest {
    return new GetNodesAndEdgesRequest().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetNodesAndEdgesRequest {
    return new GetNodesAndEdgesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetNodesAndEdgesRequest {
    return new GetNodesAndEdgesRequest().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetNodesAndEdgesRequest
      | PlainMessage<GetNodesAndEdgesRequest>
      | undefined,
    b:
      | GetNodesAndEdgesRequest
      | PlainMessage<GetNodesAndEdgesRequest>
      | undefined,
  ): boolean {
    return proto3.util.equals(GetNodesAndEdgesRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.GetNodesAndEdgesResponse
 */
export class GetNodesAndEdgesResponse extends Message<GetNodesAndEdgesResponse> {
  /**
   * @generated from field: repeated state_search.v1.LeanNode nodes = 1;
   */
  nodes: LeanNode[] = [];

  /**
   * @generated from field: repeated state_search.v1.LeanEdge edges = 2;
   */
  edges: LeanEdge[] = [];

  constructor(data?: PartialMessage<GetNodesAndEdgesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.GetNodesAndEdgesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: LeanNode, repeated: true },
    { no: 2, name: "edges", kind: "message", T: LeanEdge, repeated: true },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): GetNodesAndEdgesResponse {
    return new GetNodesAndEdgesResponse().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): GetNodesAndEdgesResponse {
    return new GetNodesAndEdgesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): GetNodesAndEdgesResponse {
    return new GetNodesAndEdgesResponse().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | GetNodesAndEdgesResponse
      | PlainMessage<GetNodesAndEdgesResponse>
      | undefined,
    b:
      | GetNodesAndEdgesResponse
      | PlainMessage<GetNodesAndEdgesResponse>
      | undefined,
  ): boolean {
    return proto3.util.equals(GetNodesAndEdgesResponse, a, b);
  }
}
